# database/db_order_utils.py
from sqlalchemy.future import select
from sqlalchemy import delete
from datetime import datetime
from .db import async_session
from .models import Order
from sqlalchemy import BigInteger
import logging

logger = logging.getLogger(__name__)

async def save_order(order: dict):
    """
    Order: {
      "user_id": int or str,
      "fullname": str,
      "phonenumber": str,
      "service_id": str,
      "barber_id": str,
      "date": "YYYY-MM-DD" or datetime.date,
      "time": "HH:MM" or datetime.time
    }
    """
    async with async_session() as session:
        try:
            # ----- VALIDATION & NORMALIZATION -----
            # user_id -> int (may be > int32)
            raw_uid = order.get("user_id")
            if raw_uid is None:
                raise ValueError("user_id required")
            user_id = int(raw_uid)

            # fullname & phonenumber fallback
            fullname = order.get("fullname") or "Noma'lum"
            phonenumber = order.get("phonenumber") or "Noma'lum"

            # date normalization
            date_val = order.get("date")
            if isinstance(date_val, str):
                date_val = datetime.strptime(date_val, "%Y-%m-%d").date()
            elif date_val is None:
                raise ValueError("date required")

            # time normalization
            time_val = order.get("time")
            if isinstance(time_val, str):
                time_val = datetime.strptime(time_val, "%H:%M").time()
            elif time_val is None:
                raise ValueError("time required")

            # ----- CREATE & COMMIT -----
            new_order = Order(
                user_id=user_id,
                fullname=fullname,
                phonenumber=phonenumber,
                service_id=order.get("service_id"),
                barber_id=order.get("barber_id"),
                date=date_val,
                time=time_val,
            )
            session.add(new_order)
            await session.commit()
            # refresh to get autogenerated id
            await session.refresh(new_order)
            return new_order

        except Exception as exc:
            await session.rollback()
            # Log full exception for debugging
            logger.exception("Failed to save order: %s", exc)
            # Reraising might be OK so caller sees failure; or return None if you prefer.
            raise

async def get_booked_times(service_id: str, barber_id: str, date: str) -> list:
    """Berilgan xizmat, barber va sana bo‘yicha band vaqtlar"""
    async with async_session() as session:
        date_obj = datetime.strptime(date, "%Y-%m-%d").date()
        result = await session.execute(
            select(Order.time).where(
                Order.service_id == service_id,
                Order.barber_id == barber_id,
                Order.date == date_obj
            )
        )
        return [row[0] for row in result.all()]

async def delete_last_order_by_user(user_id: int):
    """Foydalanuvchining oxirgi buyurtmasini o‘chirish"""
    async with async_session() as session:
        result = await session.execute(
            select(Order).where(Order.user_id == user_id).order_by(Order.id.desc())
        )
        last_order = result.scalars().first()
        if not last_order:
            return None

        await session.delete(last_order)
        await session.commit()
        return last_order

async def get_orders_by_user(user_id: int):
    """Foydalanuvchining barcha buyurtmalarini olish"""
    async with async_session() as session:
        result = await session.execute(
            select(Order).where(Order.user_id == user_id).order_by(Order.date.desc())
        )
        return result.scalars().all()
